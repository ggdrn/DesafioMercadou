<!doctype html>
<html>
  <head>
    <title>Desafio Mercadou</title>
    <!-- Estilo -->
    <link href="../css/style.css" rel="stylesheet">
    <!-- Bootstrap -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
    <!-- Vue -->
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <!-- PrismJs-->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/themes/prism.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/prism.js"></script>
  </head>
  <body>
     <header><center><h1 id="texto"> Desafio Mercadou <h1></center></header>
    <div id="app">
      <article>
        <h2><b>Questão 2:</b></h2>
        <br>
        <ol>
          <p><b>Responda as perguntas abaixo:</b><p>
          <p><b>a)</b> Eu quero retornar “hey amy” mas o código abaixo está retornando “hey
          arnold”, por que?</p>
          <pre><code class="language-js">
            function greet (person) {
             if (person == { name: 'amy' }) {
             return 'hey amy'
             } else {
             return 'hey arnold'
             }
            }
            greet({ name: 'amy' })
          </code></pre>
          <p><b>Resposta:</b> A cada vez que você cria um novo objeto, o JavaScript reserva um espaço para esse objeto na memória.
          Alguns bytes da memória do seu computador são reservados para guardar as informações desse novo objeto criado.
          E a cada novo objeto criado, um novo espaço na memória é ocupado.
          O que eu quero dizer é que, sempre que você faz isso no seu código: {}; você está criando um novo objeto.
          Com isso, o resultado do exemplo acima deu false, porque são duas variáveis diferentes! Cada um foi criado em um espaço
          diferente da memória!</p>
          <p><b>Solução:</b> ao invés de usar <b>person == { name: 'amy' }</b> vamos usar <b>person.name == 'amy'</b>, pois persom.nome
          é um valor do tipo string sendo comparada com outra string, no caso, "amy".</p>
          <p>Segue o código abaixo:</p>
          <pre><code class="language-js">
            function greet (person) {
             if (person.name == 'amy') {
             return console.log('hey amy')
             } else {
             return console.log('hey arnold')
             }
            }
            greet({ name: 'amy' });
          </code></pre>
          <br>
          <p><b>B)</b> Eu quero chamar a função bark() de Dog, porém eu recebo um erro. Por que?</p>
          <pre><code class="language-js">
            function Dog (name) {
             this.name = name
            }
            Dog.bark = function () {
             console.log(this.name + ' says woof');
            }
            let fido = new Dog('fido')
            fido.bark()
          </code></pre>
          <p><b>Resposta:</b> O que o código está tentando fazer quando faz fido.bark() é executar uma função com outra função,
          desse modo, o código não vai funcionar.Para executar no es5 temos que colocar dog.prototype.bark. para
          executar do forma que está escrita,vamos usar es6, é necessário transformar
          Dog em uma classe com o método Bark. Segue abaixo o exemplo:</p>
          <pre><code class="language-js">
            class Dog {
            	constructor(name){
              	this.name = name
                }
               bark() {
                console.log(this.name + ' says woof');
            	}
            }
            let fido = new Dog('fido');
            fido.bark();
          </code></pre>
          <p><b>C) DESAFIO:</b> Javascript é uma linguagem síncrona ou assíncrona? Explique para
            que serve “promises” em javascript e como podemos resolver-las (informe pelo menos duas formas)</p>
            <p><b>RESPOSTA:</b> Sim, JavaScript usa comunicação assíncrona. Promise é um objeto usado para
            processamento assíncrono. Um Promise (de "promessa") representa um valor que pode estar disponível agora, no futuro ou nunca.
            Uma Promise é um objeto que representa a eventual conclusão ou falha de uma operação assíncrona. Como a maioria das pessoas consomem promisses já criadas.
            Essencialmente, uma promise é um objeto retornado para o qual você adiciona callbacks, em vez de passar callbacks para uma função.
            Para resolver uma Promise podemos utilizar a função resolve, passando como parâmetro
            um valor que será acessível através de nossa Promise resolvida:</p>
            <pre><code class="language-js">
              function request() {
                return new Promise((resolve, reject) => {
                    setTimeout(() => {
                        resolve("Promise resolvida");
                    }, 5000);
                });
            }
            </code></pre>
            <p> Ou podemos usar o método then(), este possui dois argumentos, ambos são "call back functions",
             sendo uma para o sucesso e outra para o fracasso da promessa.</p>
            <pre><code class="language-js">
              p.then(quandoRealizada, quandoRejeitada);

            p.then(function(valor) {
               // sucesso
              }, function(motivo) {
              // rejeitada
            });
            </code></pre>
            <p><b>Bônus:</b> Como podemos resolver um array de promises com javascript? Escreva um exemplo.</p>
            <p><b>Resposta:</b> O método Promise.all(iterable), onde seja um objeto, como um Array ou String. Este método retorna
            uma única Promise que resolve quando todas as promises no argumento iterável forem
            resolvidas ou quando o iterável passado como argumento não contém promises.</p>
            <pre><code class="language-js">
              let promise1 = Promise.resolve(3);
              let promise2 = 42;
              let promise3 = new Promise(function(resolve, reject) {
                setTimeout(resolve, 100, 'foo');
              });

              Promise.all([promise1, promise2, promise3]).then(function(values) {
                console.log(values);
              });

            </code></pre>
        </ol>
      </article>
    <nav></nav>
    <aside></aside>
  </div>
      <!--Função javascript -->
      <script type="text/javascript" src="js/pergunta1.js"></script>
      <footer id="texto"><center>Desenvolvido por <a href="https://github.com/ggdrn" target="_blank">Gustavo Garcia ©<a/></center></footer>
  </body>
</html>
